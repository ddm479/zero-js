<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>지뢰찾기</title>
  <style>
    table {
      border-collapse: collapse;
    }

    td {
      border: 1px solid #bbb;
      text-align: center;
      line-height: 20px;
      width: 20px;
      height: 20px;
      background: #888;
    }

    td.opened {
      background: white;
    }

    td.flag {
      background: red;
    }

    td.question {
      background: orange;
    }
  </style>
</head>

<body>
  <form id="form">
    <input placeholder="가로 줄" id="row" size="5" />
    <input placeholder="세로 줄" id="cell" size="5" />
    <input placeholder="지뢰" id="mine" size="5" />
    <button>생성</button>
  </form>
  <div id="timer">0초</div>
  <table id="table">
    <tbody></tbody>
  </table>
  <div id="result"></div>
  <script>
    const $form = document.querySelector('#form');
    const $timer = document.querySelector('#timer');
    const $tbody = document.querySelector('#table tbody');
    const $result = document.querySelector('#result');

    let row, cell, mine;
    let data;
    let openCount = 0;
    let startTime;
    let interval;
    let isFirstClick = true;

    const CODE = {
      NORMAL: -1,
      QUESTION: -2,
      FLAG: -3,
      QUESTION_MINE: -4,
      FLAG_MINE: -5,
      MINE: -6,
      OPENED: 0,
    };

    // ========== 유틸 ==========
    const isMine = v => [CODE.MINE, CODE.FLAG_MINE, CODE.QUESTION_MINE].includes(v);
    const isClosed = v => [CODE.NORMAL, CODE.QUESTION, CODE.FLAG].includes(v);
    const inRange = (r, c) => r >= 0 && c >= 0 && r < row && c < cell;

    // ========== 테이블 생성 ==========
    function drawTable() {
      data = plantMine();
      $tbody.innerHTML = '';

      for (let i = 0; i < row; i++) {
        const $tr = document.createElement('tr');

        for (let j = 0; j < cell; j++) {
          const $td = document.createElement('td');
          $tr.appendChild($td);
        }
        $tbody.appendChild($tr);
      }
    }

    // ========== 지뢰 심기 ==========
    function plantMine() {
      const base = [...Array(row * cell)].map((_, i) => i);
      const mines = [];

      while (mines.length < mine) {
        const index = Math.floor(Math.random() * base.length);
        mines.push(base.splice(index, 1)[0]);
      }

      const grid = Array.from({ length: row }, () =>
        Array(cell).fill(CODE.NORMAL)
      );

      mines.forEach(n => {
        const r = Math.floor(n / cell);
        const c = n % cell;
        grid[r][c] = CODE.MINE;
      });

      return grid;
    }

    // ========== 주변 지뢰 개수 ==========
    function countMine(r, c) {
      let cnt = 0;
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (inRange(r + dr, c + dc)) {
            if (isMine(data[r + dr][c + dc])) cnt++;
          }
        }
      }
      return cnt;
    }

    // ========== 칸 열기 ==========
    function open(r, c) {
      if (!inRange(r, c)) return;
      if (data[r][c] >= 0) return;

      const $td = $tbody.children[r].children[c];
      const cnt = countMine(r, c);

      data[r][c] = cnt;
      $td.className = 'opened';
      $td.textContent = cnt || '';
      openCount++;

      if (openCount === row * cell - mine) {
        const time = (new Date() - startTime) / 1000;
        clearInterval(interval);
        alert(`승리! ${time}초`);
      }

      return cnt;
    }

    // ========== 주변 자동 오픈 BFS ==========
    function openAround(r, c) {
      const queue = [[r, c]];

      while (queue.length) {
        const [cr, cc] = queue.shift();
        const cnt = open(cr, cc);

        if (cnt === 0) {
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              const nr = cr + dr;
              const nc = cc + dc;
              if (inRange(nr, nc) && data[nr][nc] === CODE.NORMAL) {
                queue.push([nr, nc]);
              }
            }
          }
        }
      }
    }

    // ========== 첫 클릭 지뢰 이동 ==========
    function moveMineAway(r, c) {
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          const nr = r + dr;
          const nc = c + dc;

          if (!inRange(nr, nc)) continue;
          if (isClosed(data[nr][nc])) {
            data[nr][nc] = CODE.MINE;      // 새 지뢰 위치
            data[r][c] = CODE.NORMAL;      // 기존 자리는 빈칸으로 변경
            return;
          }
        }
      }
    }

    // ========== 좌클릭 ==========
    function onLeftClick(e) {
      const td = e.target;
      const r = td.parentNode.rowIndex;
      const c = td.cellIndex;
      const v = data[r][c];

      if (isFirstClick) {
        if (v === CODE.MINE) {
          moveMineAway(r, c);
        }
        openAround(r, c);
        isFirstClick = false;
        return;
      }

      if (v === CODE.NORMAL) openAround(r, c);
      else if (v === CODE.MINE) {
        td.textContent = '펑';
        td.className = 'opened';
        clearInterval(interval);
        alert('패배!');
      }
    }

    // ========== 우클릭 ==========
    function onRightClick(e) {
      e.preventDefault();
      const td = e.target;
      const r = td.parentNode.rowIndex;
      const c = td.cellIndex;
      const v = data[r][c];

      const cycle = {
        [CODE.NORMAL]: CODE.QUESTION,
        [CODE.QUESTION]: CODE.FLAG,
        [CODE.FLAG]: CODE.NORMAL,
        [CODE.MINE]: CODE.QUESTION_MINE,
        [CODE.QUESTION_MINE]: CODE.FLAG_MINE,
        [CODE.FLAG_MINE]: CODE.MINE,
      };

      data[r][c] = cycle[v] ?? v;

      td.className =
        data[r][c] === CODE.FLAG || data[r][c] === CODE.FLAG_MINE
          ? 'flag'
          : data[r][c] === CODE.QUESTION || data[r][c] === CODE.QUESTION_MINE
            ? 'question'
            : '';

      td.textContent =
        td.className === 'flag'
          ? '!'
          : td.className === 'question'
            ? '?'
            : '';
    }

    // ========== 폼 제출 ==========
    function onSubmit(e) {
      e.preventDefault();
      row = +e.target.row.value;
      cell = +e.target.cell.value;
      mine = +e.target.mine.value;

      isFirstClick = true;
      openCount = 0;

      clearInterval(interval);
      drawTable();

      startTime = new Date();
      interval = setInterval(() => {
        $timer.textContent = `${Math.floor((new Date() - startTime) / 1000)}초`;
      }, 1000);
    }

    // ========== 이벤트 한 번만 등록 ==========
    $tbody.addEventListener('click', onLeftClick);
    $tbody.addEventListener('contextmenu', onRightClick);
    $form.addEventListener('submit', onSubmit);
  </script>


</body>

</html>