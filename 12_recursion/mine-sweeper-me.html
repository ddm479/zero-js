<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>지뢰찾기</title>
  <style>
    table {
      border-collapse: collapse;
    }

    td {
      border: 1px solid #bbb;
      text-align: center;
      line-height: 20px;
      width: 20px;
      height: 20px;
      background: #888;
    }

    td.opened {
      background: white;
    }

    td.flag {
      background: red;
    }

    td.question {
      background: orange;
    }
  </style>
</head>

<body>
  <form id="form">
    <input placeholder="가로 줄" id="row" size="5" />
    <input placeholder="세로 줄" id="cell" size="5" />
    <input placeholder="지뢰" id="mine" size="5" />
    <button>생성</button>
  </form>
  <div id="timer">0초</div>
  <table id="table">
    <tbody></tbody>
  </table>
  <div id="result"></div>
  <script>
    const $form = document.querySelector('#form');
    const $timer = document.querySelector('#timer');
    const $table = document.querySelector('#table');
    const $tbody = document.querySelector('#table tbody');
    const $result = document.querySelector('#result');
    const $row = document.querySelector('#row');
    const $col = document.querySelector('#cell');
    const $mine = document.querySelector('#mine');

    // 숫자 나중에 동적으로 변경하기
    let row = 10;
    let col = 10;
    let mine = 10;
    let openedNotMineCells = 0; // 지뢰를 제외한 열린 칸 수
    const totalNotMineCells = row * col - mine; // 지뢰를 제외한 모든 칸 수
    let board;
    const rows = $table.rows;
    let startTime;


    // 상하좌우 + 대각선 방향
    const directions = [
      [-1, 0], // 위
      [1, 0], // 아래
      [0, -1], // 왼쪽
      [0, 1], // 오른쪽
      [-1, -1], // 왼쪽 위 대각
      [-1, 1], // 오른쪽 위 대각
      [1, -1], // 왼쪽 아래 대각
      [1, 1]  // 오른쪽 아래 대각
    ];

    const updateTimer = () => {
      const elapsed = Math.floor((new Date() - startTime) / 1000);
      $timer.textContent = `${elapsed}초`;
    }

    const drawTable = () => {
      // 화면에 테이블 생성
      for (let i = 0; i < row; i++) {
        const trow = document.createElement("tr");
        for (let j = 0; j < col; j++) {
          const tcell = document.createElement("td");
          trow.appendChild(tcell);
        }
        $tbody.appendChild(trow);
      }
      board = Array.from({ length: row }, () => Array(col).fill(0));

      // 지뢰 랜덤으로 배치하기
      for (let i = 0; i < mine; i++) {
        let r, c;
        do {
          r = Math.floor(Math.random() * row);
          c = Math.floor(Math.random() * col);
        } while (board[r][c] !== 0); // 이미 값이 있으면 다시
        board[r][c] = -1; // -1을 지뢰라고 가정
      }

      // 주변에 지뢰가 있는 칸들 중 주변에 지뢰 몇개인지 저장
      // -1: 지뢰, 0: 근처에 지뢰값 없다, 1 이상의 정수: 근처의 지뢰 개수
      board.forEach((rArr, r) =>
        rArr.forEach((val, c) =>
          val === -1 && directions.forEach(([dr, dc]) => {
            const nr = r + dr, nc = c + dc;
            // 유효한 칸인지 체크
            nr >= 0 && nr < row && nc >= 0 && nc < col && board[nr][nc] !== -1 && board[nr][nc]++;
            // 앞 조건이 false면 뒤를 실행하지 않음, 마지막 전까지 전부 true면 -> 마지막 실행한다.
            // a && b 연장함
          })
        )
      );
      console.log(board);
      startTime = new Date();
    }

    const onSubmit = (event) => {
      event.preventDefault();
      console.log(event.target, event.target.row);
      row = parseInt($row.value);
      // 단축평가, a || b -> a가 false면 b실행
      col = parseInt(event.target.cell.value) || 0;
      // <form>요소 submit 이벤트 핸들러에서 폼 내부의 모든 name 속성을 가진 입력 요소를 마치 폼 객체의 속성처럼 접근할 수 있도록 해줍니다.
      mine = parseInt($mine.value) || 0;
      if (isNaN(row)) row = 0; // NaN 체크
      //drawTable();
    }

    const onRightClick = (event) => {
      event.preventDefault();
      const td = event.target;
      const cls = td.classList;
      console.log('onRightClick: ', td, td.textContent);
      // 이미 열린(밝혀진)칸인가?
      if (cls.contains('opened')) {
        return;
      }
      // 깃발 칸인가?
      if (cls.contains('flag')) {
        cls.replace('flag', 'question');
        td.textContent = '?';
        return;
      } else if (cls.contains('question')) {
        // '?' 칸인가?
        cls.remove('question');
        td.textContent = '';
        return;
      } else {
        // 아니라면 깃발표시
        cls.add('flag');
        td.textContent = '!';
      }

    }
    const onLeftClick = (event) => {
      const td = event.target;
      console.log('onLeftClick: ', event, td);
      // 깃발 혹은 '?' 표시한 부분 좌클릭 막기
      if (td.matches('.flag, .question')) {
        return;
      }
      open(td);


      // 지뢰를 제외하고 모든칸을 다 열었나?
      if (openedNotMineCells === totalNotMineCells) {
        $result.textContent = `${((new Date() - startTime) / 1000).toFixed(2)}초 걸렸습니다`;
        $tbody.removeEventListener('contextmenu', onRightClick);
        $tbody.removeEventListener('click', onLeftClick);
        clearInterval(intervalId);
      }
    }
    // 칸 열기
    const open = (td) => {
      const cls = td.classList;
      const rowIndex = td.parentNode.rowIndex;
      const cellIndex = td.cellIndex;
      const value = board[rowIndex][cellIndex];
      // 이미 열린칸인가?
      if (cls.contains('opened')) {
        return;
      }
      // 지뢰 칸인가?
      if (value === -1) {
        cls.add('opened');
        td.textContent = '펑';
        $tbody.removeEventListener('click', onLeftClick);
        $tbody.removeEventListener('contextmenu', onRightClick);
        clearInterval(intervalId);
        // alert에 setTimeout()을 준거는 화면이 바뀌는 시간을 기다리려고
        setTimeout(() => {
          alert('실패');
        }, 1000);
      } else if (value > 0) {
        // 숫자 칸이면
        cls.forEach(c => {
          // 혹시 깃발이나 '?'표시를 해놨다면
          if (c === "flag" || c === "question") {
            cls.remove(c); // 해당 표시 제거하기
          }
        })
        cls.add('opened');
        td.textContent = value;
        openedNotMineCells++;
      } else if (value === 0) {
        // 값이 없는 칸이면
        cls.forEach(c => {
          // 혹시 깃발이나 '?'표시를 해놨다면
          if (c === "flag" || c === "question") {
            cls.remove(c); // 해당 표시 제거하기
          }
        })
        cls.add('opened'); // 일단 현재 칸 열고
        td.textContent = '';
        openedNotMineCells++;
        for (const [dr, dc] of directions) {
          const r = rowIndex + dr;
          const c = cellIndex + dc;
          const neighborCell = rows[r]?.cells[c]; // 주변 칸
          // 옵셔널 체이닝 -> = rows[r] && rows[r].cells[c]
          // 주변 칸이 유효한 위치인지 체크하고 열린적이 없다면
          if (neighborCell && !neighborCell.classList.contains('opened')) {
            open(neighborCell); // 주변 칸을 연다
          }
        }
      }
      console.log(openedNotMineCells)
    }
    drawTable();
    const intervalId = setInterval(updateTimer, 1000);
    $form.addEventListener('submit', onSubmit);

    // 노트북 터치 패드 우클릭 후 click이벤트 발생 이슈, 하드웨어 문제인듯
    $tbody.addEventListener('contextmenu', onRightClick);
    $tbody.addEventListener('click', onLeftClick);
  </script>
</body>

</html>