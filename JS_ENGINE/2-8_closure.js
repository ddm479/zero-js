// 클로저: 함수와 외부 변수와의 관계이다.
// 클로저 문제 -> 스코프, 비동기, var가 섞인 복합적인 문제
// 클로저 문제는 클로저를 사용해서 해결하는 문제
// for문(반복문)과 비동기를 함께 사용하면 종종 발생한다.

// 문제발생
function a() {
    // var i는 function a 전체를 범위로 하는 함수 스코프를 갖는다.
    for (var i = 0; i < 5; i++) {
        setTimeout(() => {
            console.log(i); // setTimeout의 콜백함수는 나중에 실행
        }, i * 1000); // setTimeout 함수 자체는 그 즉시 실행
    }
}
a(); // 5 5 5 5 5
// var i 면 a스코프에 포함되고 let i면 for문 스코프에 포함된다.
// function a 스코프는 1개고, for문의 스코프는 5개
// a스코프에서 i는 0->5가 되는거고, for문의 스코프 5개에서 i는 각각 0,1,2,3,4


// 해결법1: var 유지해야한다면 즉시실행함수로 클로저 생성
// -> 클로저 통해서 해결한 방법
const x = 1;  // 변수 x와 function b는 클로저 관계
function b() {
    for (var i = 0; i < 5; i++) {
        (function (j) {
            // var j = i; 이게 생략되었다고 생각
            // 반복문 돌때마다 새로운 '함수 스코프' 생성
            setTimeout(() => {
                console.log(j);
            }, i * 1000);
        })(i)
        // 여기서 var i(외부변수)와 (function(j){})(함수)가 클로저 관계를 형성함
        // () => {console.log(j);}랑 앞의 함수 외부에 선언한 변수 j도 클로저 관계
    }
}
b(); // 0 1 2 3 4 

// 해결법2: var -> let으로 변경
// for문에 let이 사용되면 반복할 때마다 매번 새로운 블록 스코프(상자)를 생성한다.
function c() {
    for (let i = 0; i < 5; i++) {
        // 2 -> 블록 스코프(여기서는 반복문 안)에 있으면: 콜백 함수마다 자기만의 변수를 가진다. (예약 당시의 값을 유지함)
        setTimeout(() => {
            console.log(i);
        }, i * 1000);
    }
}
c(); // 0 1 2 3 4 

// 2. a함수와 c함수와 비교하면서 생각해보기
function d() {
    let i = 0;
    // 2 -> 상위 스코프에 있으면: 모든 콜백 함수가 변수 하나를 공유한다. (나중에 실행될 땐 이미 값이 변해 있음)
    while (i < 5) {
        setTimeout(() => {
            console.log(i);
        }, i * 1000);
        ++i;
    }
}

d();